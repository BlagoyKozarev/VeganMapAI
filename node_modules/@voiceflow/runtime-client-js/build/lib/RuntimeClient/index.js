"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RuntimeClient = void 0;
const general_types_1 = require("@voiceflow/general-types");
const bluebird_1 = __importDefault(require("bluebird"));
const Common_1 = require("../Common");
const Context_1 = __importDefault(require("../Context"));
const Events_1 = __importDefault(require("../Events"));
const types_1 = require("../types");
const utils_1 = require("./utils");
class RuntimeClient {
    constructor(state, { client, dataConfig = {} }) {
        this.responseHandler = async () => {
            /** empty */
        };
        this.client = client;
        this.dataConfig = dataConfig;
        this.events = new Events_1.default();
        this.context = new Context_1.default({ request: null, state, trace: [] });
    }
    async start() {
        this.context = new Context_1.default(utils_1.resetContext(this.context.toJSON()));
        return this.sendRequest(null);
    }
    async sendText(userInput) {
        var _a;
        if (!((_a = userInput === null || userInput === void 0 ? void 0 : userInput.trim) === null || _a === void 0 ? void 0 : _a.call(userInput))) {
            return this.sendRequest(null);
        }
        return this.sendRequest({ type: general_types_1.RequestType.TEXT, payload: userInput });
    }
    async sendIntent(name, entities = [], query = '', confidence) {
        return this.sendRequest({ type: general_types_1.RequestType.INTENT, payload: { intent: { name }, entities, query, confidence } });
    }
    async sendRequest(request) {
        if (this.context.isEnding()) {
            throw new Common_1.VFClientError('RuntimeClient.sendText() was called but the conversation has ended');
        }
        this.setContext(await this.client.interact(utils_1.makeRequestBody(this.context, request, this.dataConfig)));
        await new bluebird_1.default(async (resolve) => {
            await this.events.handleProcessing(types_1.TraceEvent.BEFORE_PROCESSING, this.context);
            await bluebird_1.default.each(this.context.getTrace(), async (trace) => {
                await this.events.handleTrace(trace, this.context);
            });
            await this.events.handleProcessing(types_1.TraceEvent.AFTER_PROCESSING, this.context);
            resolve();
        });
        return this.buildResponse();
    }
    on(event, handler) {
        if (Common_1.isValidTraceType(event)) {
            return this.events.onTraceType(event, handler);
        }
        if (Common_1.isValidTraceEvent(event)) {
            return Common_1.isGeneralTraceEvent(event)
                ? this.events.onGeneral(handler)
                : this.events.onTraceEvent(event, handler);
        }
        throw new Common_1.VFTypeError(`event "${event}" is not valid`);
    }
    async onResponse(responseHandler) {
        this.responseHandler = responseHandler;
    }
    async buildResponse() {
        var _a, _b, _c;
        if (this.context.isEnding())
            return this.context;
        const traces = this.context.getTrace();
        const lastTrace = traces[traces.length - 1];
        if (!types_1.is_V1Trace(lastTrace))
            return this.context;
        const path = (_a = (await this.responseHandler(lastTrace, this.context))) !== null && _a !== void 0 ? _a : lastTrace.defaultPath;
        if (typeof path !== 'number')
            return this.context;
        const type = (_c = (_b = (lastTrace.paths || [])[path]) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.type;
        if (!type)
            return this.context;
        return this.sendRequest({ type, payload: {} });
    }
    off(event, handler) {
        if (Common_1.isValidTraceType(event)) {
            return this.events.offTraceType(event, handler);
        }
        if (Common_1.isValidTraceEvent(event)) {
            return Common_1.isGeneralTraceEvent(event)
                ? this.events.offGeneral(handler)
                : this.events.offTraceEvent(event, handler);
        }
        throw new Common_1.VFTypeError(`event "${event}" is not valid`);
    }
    onSpeak(handler) {
        this.events.onTraceType(types_1.TraceType.SPEAK, handler);
    }
    onAudio(handler) {
        this.events.onTraceType(types_1.TraceType.AUDIO, handler);
    }
    onBlock(handler) {
        this.events.onTraceType(types_1.TraceType.BLOCK, handler);
    }
    onDebug(handler) {
        this.events.onTraceType(types_1.TraceType.DEBUG, handler);
    }
    onEnd(handler) {
        this.events.onTraceType(types_1.TraceType.END, handler);
    }
    onFlow(handler) {
        this.events.onTraceType(types_1.TraceType.FLOW, handler);
    }
    onVisual(handler) {
        this.events.onTraceType(types_1.TraceType.VISUAL, handler);
    }
    onChoice(handler) {
        this.events.onTraceType(types_1.TraceType.CHOICE, handler);
    }
    setContext(contextJSON) {
        this.context = new Context_1.default(contextJSON);
    }
    getContext() {
        return this.context;
    }
}
exports.RuntimeClient = RuntimeClient;
exports.default = RuntimeClient;
//# sourceMappingURL=index.js.map