# üß™ GBGPT BULK RESTAURANT TEST - 50 –°–û–§–ò–Ø –†–ï–°–¢–û–†–ê–ù–¢–ê

## üéØ –¶–ï–õ –ù–ê –¢–ï–°–¢–ê
–ó–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ 50 –Ω–æ–≤–∏ —Ä–µ—Å—Ç–æ—Ä–∞–Ω—Ç–∞ –≤ –°–æ—Ñ–∏—è –∏ —Ç–µ—Å—Ç–≤–∞–Ω–µ –Ω–∞ GBGPT AI scoring –≤ production environment.

---

## üìã –°–¢–™–ü–ö–ê 1: –°—ä–∑–¥–∞–π Test Endpoint –∑–∞ Bulk Import

### –°—ä–∑–¥–∞–π `server/routes/bulkTestGBGPT.ts`:

```typescript
import express from 'express';
import { GBGPTProvider } from '../providers/gbgptProvider.js';
import { db } from '../db.js';
import { restaurants } from '../../shared/schema.js';

const router = express.Router();

/**
 * Bulk import –∏ scoring –Ω–∞ –Ω–æ–≤–∏ —Ä–µ—Å—Ç–æ—Ä–∞–Ω—Ç–∏
 */
router.post('/bulk-test-gbgpt', async (req, res) => {
  try {
    console.log('üöÄ Starting bulk GBGPT test with 50 Sofia restaurants...');
    
    // Sample –°–æ—Ñ–∏—è —Ä–µ—Å—Ç–æ—Ä–∞–Ω—Ç–∏ –∑–∞ —Ç–µ—Å—Ç–≤–∞–Ω–µ
    const testRestaurants = [
      {
        name: "–ö–∞—Ñ–µ-—Ä–µ—Å—Ç–æ—Ä–∞–Ω—Ç –ö–æ—Å–º–æ—Å",
        address: "—É–ª. –í–∏—Ç–æ—à–∞ 45, –°–æ—Ñ–∏—è",
        cuisineTypes: ["cafe", "bulgarian"],
        lat: 42.6977,
        lng: 23.3219,
        description: "–¢—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω–∞ –±—ä–ª–≥–∞—Ä—Å–∫–∞ –∫—É—Ö–Ω—è —Å –º–æ–¥–µ—Ä–µ–Ω –ø–æ–¥—Ö–æ–¥"
      },
      {
        name: "–ü–∏—Ü–∞ –¢–µ–º–ø–æ",
        address: "–±—É–ª. –í–∞—Å–∏–ª –õ–µ–≤—Å–∫–∏ 132, –°–æ—Ñ–∏—è", 
        cuisineTypes: ["pizza", "italian"],
        lat: 42.6869,
        lng: 23.3228,
        description: "–ò—Ç–∞–ª–∏–∞–Ω—Å–∫–∞ –ø–∏—Ü–∞—Ä–∏—è —Å fresh ingredients"
      },
      {
        name: "–†–µ—Å—Ç–æ—Ä–∞–Ω—Ç Made in Home",
        address: "—É–ª. –û–±–æ—Ä–∏—â–µ 42, –°–æ—Ñ–∏—è",
        cuisineTypes: ["modern_european", "healthy"],
        lat: 42.6886,
        lng: 23.3394,
        description: "–ó–¥—Ä–∞–≤–æ—Å–ª–æ–≤–Ω–∞ –∫—É—Ö–Ω—è —Å –¥–æ–º–∞—à–µ–Ω –≤–∫—É—Å"
      },
      {
        name: "Ethno",
        address: "—É–ª. –î—è–∫–æ–Ω –ò–≥–Ω–∞—Ç–∏–π 4, –°–æ—Ñ–∏—è",
        cuisineTypes: ["traditional", "bulgarian"],
        lat: 42.6948,
        lng: 23.3227,
        description: "–ê–≤—Ç–µ–Ω—Ç–∏—á–Ω–∞ –±—ä–ª–≥–∞—Ä—Å–∫–∞ –∫—É—Ö–Ω—è –≤ —Å—Ç–∏–ª–Ω–∞ –æ–±—Å—Ç–∞–Ω–æ–≤–∫–∞"
      },
      {
        name: "Rainbow Factory",
        address: "—É–ª. –¶–∞—Ä –°–∞–º—É–∏–ª 25, –°–æ—Ñ–∏—è",
        cuisineTypes: ["healthy", "vegetarian"],
        lat: 42.6953,
        lng: 23.3264,
        description: "–ó–¥—Ä–∞–≤–æ—Å–ª–æ–≤–Ω–∏ –∏ vegetarian –æ–ø—Ü–∏–∏"
      },
      {
        name: "Salad Studio",
        address: "–±—É–ª. –í–∏—Ç–æ—à–∞ 89, –°–æ—Ñ–∏—è",
        cuisineTypes: ["healthy", "salads"],
        lat: 42.6934,
        lng: 23.3197,
        description: "Fresh —Å–∞–ª–∞—Ç–∏ –∏ –∑–¥—Ä–∞–≤–æ—Å–ª–æ–≤–Ω–∏ —è—Å—Ç–∏—è"
      },
      {
        name: "Bistro Pesto",
        address: "—É–ª. –®–∏—à–º–∞–Ω 12, –°–æ—Ñ–∏—è",
        cuisineTypes: ["italian", "bistro"],
        lat: 42.6891,
        lng: 23.3312,
        description: "–ò—Ç–∞–ª–∏–∞–Ω—Å–∫–æ bistro —Å fresh pasta"
      },
      {
        name: "Green House",
        address: "—É–ª. –ì—Ä–∞—Ñ –ò–≥–Ω–∞—Ç–∏–µ–≤ 64, –°–æ—Ñ–∏—è",
        cuisineTypes: ["healthy", "organic"],
        lat: 42.6847,
        lng: 23.3254,
        description: "–û—Ä–≥–∞–Ω–∏—á–Ω–∞ —Ö—Ä–∞–Ω–∞ –∏ –∑–µ–ª–µ–Ω–∏ smoothies"
      },
      {
        name: "Asia Garden",
        address: "–±—É–ª. –ß–µ—Ä–Ω–∏ –≤—Ä—ä—Ö 47, –°–æ—Ñ–∏—è",
        cuisineTypes: ["asian", "thai"],
        lat: 42.6712,
        lng: 23.3156,
        description: "–ê–≤—Ç–µ–Ω—Ç–∏—á–Ω–∞ –∞–∑–∏–∞—Ç—Å–∫–∞ –∫—É—Ö–Ω—è"
      },
      {
        name: "Vegetarian Delight",
        address: "—É–ª. –†–∞–∫–æ–≤—Å–∫–∏ 95, –°–æ—Ñ–∏—è", 
        cuisineTypes: ["vegetarian", "vegan"],
        lat: 42.6923,
        lng: 23.3278,
        description: "100% vegetarian —Ä–µ—Å—Ç–æ—Ä–∞–Ω—Ç —Å vegan –æ–ø—Ü–∏–∏"
      }
      // ... –¥–æ–±–∞–≤–∏ –æ—â–µ 40 —Ä–µ—Å—Ç–æ—Ä–∞–Ω—Ç–∞ —Ç—É–∫
    ];

    // Extend array to 50 restaurants
    const allTestRestaurants = [...testRestaurants];
    
    // Generate 40 more restaurants with variations
    for (let i = 10; i < 50; i++) {
      allTestRestaurants.push({
        name: `–¢–µ—Å—Ç –†–µ—Å—Ç–æ—Ä–∞–Ω—Ç ${i + 1}`,
        address: `—É–ª. –¢–µ—Å—Ç–æ–≤–∞ ${i + 1}, –°–æ—Ñ–∏—è`,
        cuisineTypes: ["restaurant", "international"],
        lat: 42.6977 + (Math.random() - 0.5) * 0.1,
        lng: 23.3219 + (Math.random() - 0.5) * 0.1,
        description: `–¢–µ—Å—Ç–æ–≤ —Ä–µ—Å—Ç–æ—Ä–∞–Ω—Ç –Ω–æ–º–µ—Ä ${i + 1} –∑–∞ GBGPT –∞–Ω–∞–ª–∏–∑`
      });
    }

    console.log(`üìä Processing ${allTestRestaurants.length} restaurants with GBGPT...`);
    
    const gbgpt = new GBGPTProvider();
    const results = [];
    const failures = [];
    let processed = 0;

    // Process in batches of 5 to avoid overwhelming GBGPT
    for (let i = 0; i < allTestRestaurants.length; i += 5) {
      const batch = allTestRestaurants.slice(i, i + 5);
      
      console.log(`üîÑ Processing batch ${Math.floor(i/5) + 1}/${Math.ceil(allTestRestaurants.length/5)}`);
      
      const batchPromises = batch.map(async (restaurant, index) => {
        try {
          // Add delay between requests (1 second apart)
          await new Promise(resolve => setTimeout(resolve, index * 1000));
          
          console.log(`üîÑ Scoring: ${restaurant.name}`);
          const startTime = Date.now();
          
          const score = await gbgpt.scoreRestaurant(restaurant);
          const duration = Date.now() - startTime;
          
          processed++;
          console.log(`‚úÖ ${restaurant.name} scored in ${duration}ms (${processed}/${allTestRestaurants.length})`);
          
          return {
            restaurant,
            score,
            duration,
            success: true
          };
          
        } catch (error) {
          console.error(`‚ùå Failed to score ${restaurant.name}:`, error.message);
          
          return {
            restaurant,
            error: error.message,
            success: false
          };
        }
      });

      const batchResults = await Promise.allSettled(batchPromises);
      
      batchResults.forEach((result) => {
        if (result.status === 'fulfilled') {
          if (result.value.success) {
            results.push(result.value);
          } else {
            failures.push(result.value);
          }
        }
      });

      // Progress update
      const successRate = ((results.length / processed) * 100).toFixed(1);
      console.log(`üìä Progress: ${processed}/${allTestRestaurants.length} (${successRate}% success rate)`);
      
      // Pause between batches (5 seconds)
      if (i + 5 < allTestRestaurants.length) {
        console.log('‚è≥ Waiting 5 seconds before next batch...');
        await new Promise(resolve => setTimeout(resolve, 5000));
      }
    }

    // Calculate statistics
    const avgDuration = results.reduce((sum, r) => sum + r.duration, 0) / results.length;
    const avgScore = results.reduce((sum, r) => sum + r.score.overallScore, 0) / results.length;
    
    const stats = {
      totalProcessed: allTestRestaurants.length,
      successful: results.length,
      failed: failures.length,
      successRate: `${((results.length / allTestRestaurants.length) * 100).toFixed(1)}%`,
      averageResponseTime: `${avgDuration.toFixed(0)}ms`,
      averageVeganScore: avgScore.toFixed(2),
      timestamp: new Date().toISOString()
    };

    console.log('üéâ Bulk test completed!', stats);

    res.json({
      success: true,
      stats,
      results: results.slice(0, 10), // First 10 for preview
      failures: failures.slice(0, 5),  // First 5 failures
      message: `GBGPT bulk test completed: ${results.length}/${allTestRestaurants.length} successful`
    });
    
  } catch (error) {
    console.error('‚ùå Bulk GBGPT test failed:', error);
    
    res.status(500).json({
      success: false,
      error: error.message,
      message: 'Bulk GBGPT test failed'
    });
  }
});

/**
 * Import successful results to database
 */
router.post('/import-gbgpt-results', async (req, res) => {
  try {
    const { results } = req.body;
    
    if (!results || !Array.isArray(results)) {
      return res.status(400).json({ error: 'Results array required' });
    }

    console.log(`üì§ Importing ${results.length} GBGPT-scored restaurants to database...`);
    
    const imported = [];
    
    for (const result of results) {
      try {
        const { restaurant, score } = result;
        
        // Insert restaurant with GBGPT score
        const [insertedRestaurant] = await db.insert(restaurants).values({
          name: restaurant.name,
          address: restaurant.address,
          cuisineTypes: restaurant.cuisineTypes,
          latitude: restaurant.lat,
          longitude: restaurant.lng,
          description: restaurant.description,
          veganScore: score.overallScore,
          scoreBreakdown: score.dimensions,
          scoreReasoning: score.reasoning,
          scoreProvider: 'GBGPT',
          scoredAt: new Date()
        }).returning();
        
        imported.push(insertedRestaurant);
        console.log(`‚úÖ Imported: ${restaurant.name} (Score: ${score.overallScore})`);
        
      } catch (error) {
        console.error(`‚ùå Failed to import ${result.restaurant.name}:`, error.message);
      }
    }

    res.json({
      success: true,
      imported: imported.length,
      message: `Successfully imported ${imported.length} restaurants with GBGPT scores`
    });
    
  } catch (error) {
    console.error('‚ùå Import failed:', error);
    
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

export default router;
```

---

## –°–¢–™–ü–ö–ê 2: –î–æ–±–∞–≤–∏ Route –≤ Main Server

–î–æ–±–∞–≤–∏ –≤ `server/index.ts`:

```typescript
import bulkTestGBGPTRouter from './routes/bulkTestGBGPT.js';

// Add to routes
app.use('/api', bulkTestGBGPTRouter);
```

---

## –°–¢–™–ü–ö–ê 3: Execute Bulk Test

### Test Commands:

**1. Health Check –ø—ä—Ä–≤–æ:**
```bash
GET /api/gbgpt-health
```

**2. Run Bulk Test:**
```bash
POST /api/bulk-test-gbgpt
# Body: {} (empty, —â–µ –∏–∑–ø–æ–ª–∑–≤–∞ –≤–≥—Ä–∞–¥–µ–Ω–∏—Ç–µ —Ç–µ—Å—Ç –¥–∞–Ω–Ω–∏)
```

**3. Import Results (–∞–∫–æ successful):**
```bash
POST /api/import-gbgpt-results
# Body: { "results": [array of successful results] }
```

---

## –°–¢–™–ü–ö–ê 4: Monitoring & Analysis

### Expected Timeline:
```
- 50 —Ä–µ—Å—Ç–æ—Ä–∞–Ω—Ç–∞ √ó 10 —Å–µ–∫—É–Ω–¥–∏ = ~8 –º–∏–Ω—É—Ç–∏ total
- Batch processing (5 restaurants at a time) = 10 batches
- –ü–∞—É–∑–∏ –º–µ–∂–¥—É batches = ~5 –º–∏–Ω—É—Ç–∏
- Total –≤—Ä–µ–º–µ: ~15-20 –º–∏–Ω—É—Ç–∏
```

### Success Metrics:
- **Target Success Rate:** >80% (40+ –æ—Ç 50)
- **Average Response Time:** <15 —Å–µ–∫—É–Ω–¥–∏ per restaurant
- **Score Distribution:** Reasonable spread (1-5 range)
- **Bulgarian Quality:** Meaningful reasoning –Ω–∞ –±—ä–ª–≥–∞—Ä—Å–∫–∏

---

## –°–¢–™–ü–ö–ê 5: Fallback Testing

–°–ª–µ–¥ GBGPT —Ç–µ—Å—Ç, —Ç–µ—Å—Ç–≤–∞–π OpenAI fallback:

```bash
# Temporary disable GBGPT (set wrong API key)
# Run same bulk test
# Should fallback to OpenAI and complete –≤ <5 —Å–µ–∫—É–Ω–¥–∏ per restaurant
```

---

## üìä EXPECTED RESULTS FORMAT

```json
{
  "stats": {
    "totalProcessed": 50,
    "successful": 42,
    "failed": 8,
    "successRate": "84.0%",
    "averageResponseTime": "12543ms",
    "averageVeganScore": 3.2
  },
  "results": [
    {
      "restaurant": { "name": "–ö–∞—Ñ–µ-—Ä–µ—Å—Ç–æ—Ä–∞–Ω—Ç –ö–æ—Å–º–æ—Å", ... },
      "score": {
        "overallScore": 3.4,
        "dimensions": { "menuVariety": 6, ... },
        "reasoning": "–†–µ—Å—Ç–æ—Ä–∞–Ω—Ç—ä—Ç –∏–º–∞ –Ω—è–∫–æ–ª–∫–æ vegan –æ–ø—Ü–∏–∏...",
        "confidence": 0.7,
        "provider": "GBGPT"
      },
      "duration": 11250
    }
  ]
}
```

---

## ‚ö†Ô∏è TROUBLESHOOTING

### –ê–∫–æ GBGPT –Ω–µ –µ –¥–æ—Å—Ç—ä–ø–µ–Ω:
```
Expected: Network failures –∑–∞—Ä–∞–¥–∏ private IP
Solution: –í—Å–∏—á–∫–∏ requests —â–µ fallback –∫—ä–º OpenAI
Result: –ë—ä—Ä–∑–æ —Ç–µ—Å—Ç–≤–∞–Ω–µ –Ω–∞ fallback logic
```

### –ê–∫–æ –∏–º–∞ timeout errors:
```
Action: –£–≤–µ–ª–∏—á–∏ timeout –Ω–∞ 30 —Å–µ–∫—É–Ω–¥–∏
Code: this.timeout = 30000;
```

### –ê–∫–æ –∏–º–∞ parsing errors:
```
Debug: Log —Ü—è–ª–æ—Å—Ç–Ω–∏—è GBGPT response
Add: More robust JSON extraction
```

---

## üéØ SUCCESS CRITERIA

### –ó–∞ –¥–∞ —Å—á–∏—Ç–∞–º–µ —Ç–µ—Å—Ç–∞ —É—Å–ø–µ—à–µ–Ω:
- ‚úÖ **Bulk endpoint —Ä–∞–±–æ—Ç–∏** –±–µ–∑ server crashes
- ‚úÖ **Batch processing** handles 50 restaurants
- ‚úÖ **Fallback logic** —Å–µ –∞–∫—Ç–∏–≤–∏—Ä–∞ –ø—Ä–∏ GBGPT failure
- ‚úÖ **Database import** –∑–∞–ø–∏—Å–≤–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏—Ç–µ –ø—Ä–∞–≤–∏–ª–Ω–æ
- ‚úÖ **Performance metrics** —Å–∞ reasonable (–¥–∞–∂–µ —Å—ä—Å slow GBGPT)

### Bonus Success:
- üéÅ **GBGPT connectivity** —Ä–∞–±–æ—Ç–∏ –æ—Ç Replit cloud
- üéÅ **Bulgarian responses** —Å–∞ high quality
- üéÅ **Score distribution** –µ realistic –∑–∞ –°–æ—Ñ–∏—è —Ä–µ—Å—Ç–æ—Ä–∞–Ω—Ç–∏

---

## üöÄ DEPLOYMENT INSTRUCTIONS

**1. –ü—ä—Ä–≤–æ —Å—ä–∑–¥–∞–π —Ñ–∞–π–ª–∞**
**2. Import route –≤ server**  
**3. Test connectivity —Å health check**
**4. Run bulk test**
**5. Analyze results –∏ import –∞–∫–æ —Å–∞ good**

**Ready to execute bulk GBGPT test?** üß™

---

## –°–¢–™–ü–ö–ê 6: –°—ä–∑–¥–∞–π Comprehensive Test Report

### –°—ä–∑–¥–∞–π `server/reports/gbgptTestReport.ts`:

```typescript
interface TestResult {
  restaurant: any;
  score?: any;
  duration?: number;
  error?: string;
  success: boolean;
  provider: 'GBGPT' | 'OpenAI';
}

interface TestMetrics {
  totalRestaurants: number;
  successfulGBGPT: number;
  fallbackToOpenAI: number;
  totalFailures: number;
  averageGBGPTResponseTime: number;
  averageOpenAIResponseTime: number;
  averageVeganScore: number;
  costAnalysis: {
    gbgptCostPerRequest: number;
    openaiCostPerRequest: number;
    totalEstimatedCost: number;
  };
  qualityAnalysis: {
    scoreDistribution: Record<string, number>;
    reasoningQuality: 'Poor' | 'Fair' | 'Good' | 'Excellent';
    bulgarianLanguageQuality: 'Poor' | 'Fair' | 'Good' | 'Excellent';
  };
}

export class GBGPTTestReporter {
  
  /**
   * Generate comprehensive test report
   */
  static generateReport(results: TestResult[]): TestMetrics {
    const gbgptResults = results.filter(r => r.success && r.provider === 'GBGPT');
    const openaiResults = results.filter(r => r.success && r.provider === 'OpenAI');
    const failures = results.filter(r => !r.success);

    // Performance Analysis
    const avgGBGPTTime = gbgptResults.length > 0 
      ? gbgptResults.reduce((sum, r) => sum + (r.duration || 0), 0) / gbgptResults.length
      : 0;

    const avgOpenAITime = openaiResults.length > 0
      ? openaiResults.reduce((sum, r) => sum + (r.duration || 0), 0) / openaiResults.length  
      : 0;

    // Score Analysis
    const successfulResults = [...gbgptResults, ...openaiResults];
    const avgScore = successfulResults.length > 0
      ? successfulResults.reduce((sum, r) => sum + (r.score?.overallScore || 0), 0) / successfulResults.length
      : 0;

    // Score Distribution Analysis
    const scoreDistribution = {
      '1.0-2.0': 0,
      '2.1-3.0': 0, 
      '3.1-4.0': 0,
      '4.1-5.0': 0
    };

    successfulResults.forEach(result => {
      const score = result.score?.overallScore || 0;
      if (score <= 2.0) scoreDistribution['1.0-2.0']++;
      else if (score <= 3.0) scoreDistribution['2.1-3.0']++;
      else if (score <= 4.0) scoreDistribution['3.1-4.0']++;
      else scoreDistribution['4.1-5.0']++;
    });

    // Cost Analysis (estimates)
    const gbgptCostPer1000Tokens = 0.002; // $0.002 per 1K tokens (estimate)
    const openaiCostPer1000Tokens = 0.03;  // $0.03 per 1K tokens (GPT-4o)
    const avgTokensPerRequest = 800; // Estimate –∑–∞ vegan scoring

    const gbgptCost = (gbgptResults.length * avgTokensPerRequest * gbgptCostPer1000Tokens) / 1000;
    const openaiCost = (openaiResults.length * avgTokensPerRequest * openaiCostPer1000Tokens) / 1000;

    // Quality Analysis
    const reasoningQuality = this.analyzeReasoningQuality(gbgptResults);
    const bulgarianQuality = this.analyzeBulgarianQuality(gbgptResults);

    return {
      totalRestaurants: results.length,
      successfulGBGPT: gbgptResults.length,
      fallbackToOpenAI: openaiResults.length,
      totalFailures: failures.length,
      averageGBGPTResponseTime: Math.round(avgGBGPTTime),
      averageOpenAIResponseTime: Math.round(avgOpenAITime),
      averageVeganScore: Math.round(avgScore * 100) / 100,
      costAnalysis: {
        gbgptCostPerRequest: Math.round(gbgptCost / gbgptResults.length * 10000) / 10000,
        openaiCostPerRequest: Math.round(openaiCost / openaiResults.length * 10000) / 10000,
        totalEstimatedCost: Math.round((gbgptCost + openaiCost) * 100) / 100
      },
      qualityAnalysis: {
        scoreDistribution,
        reasoningQuality,
        bulgarianLanguageQuality: bulgarianQuality
      }
    };
  }

  /**
   * Analyze reasoning quality
   */
  private static analyzeReasoningQuality(results: TestResult[]): 'Poor' | 'Fair' | 'Good' | 'Excellent' {
    if (results.length === 0) return 'Poor';
    
    const reasoningLengths = results
      .map(r => r.score?.reasoning?.length || 0)
      .filter(len => len > 0);

    const avgLength = reasoningLengths.reduce((sum, len) => sum + len, 0) / reasoningLengths.length;
    
    // Quality assessment based –Ω–∞ reasoning length –∏ complexity
    if (avgLength < 50) return 'Poor';
    if (avgLength < 100) return 'Fair';  
    if (avgLength < 200) return 'Good';
    return 'Excellent';
  }

  /**
   * Analyze Bulgarian language quality
   */
  private static analyzeBulgarianQuality(results: TestResult[]): 'Poor' | 'Fair' | 'Good' | 'Excellent' {
    if (results.length === 0) return 'Poor';
    
    const bulgarianTexts = results
      .map(r => r.score?.reasoning || '')
      .filter(text => text.length > 0);

    // Check –∑–∞ Bulgarian characters –∏ structure
    const bulgarianCharCount = bulgarianTexts.reduce((count, text) => {
      const bulgarianChars = text.match(/[–∞-—è]/gi) || [];
      return count + bulgarianChars.length;
    }, 0);

    const totalChars = bulgarianTexts.join('').length;
    const bulgarianRatio = totalChars > 0 ? bulgarianCharCount / totalChars : 0;

    // Quality assessment
    if (bulgarianRatio < 0.3) return 'Poor';   // <30% Bulgarian chars
    if (bulgarianRatio < 0.6) return 'Fair';   // 30-60% Bulgarian chars  
    if (bulgarianRatio < 0.8) return 'Good';   // 60-80% Bulgarian chars
    return 'Excellent';                        // >80% Bulgarian chars
  }

  /**
   * Generate detailed markdown report
   */
  static generateMarkdownReport(metrics: TestMetrics, results: TestResult[]): string {
    const timestamp = new Date().toLocaleString('bg-BG');
    
    return `# üìä GBGPT BULK TEST REPORT

**Test Date:** ${timestamp}  
**Total Restaurants:** ${metrics.totalRestaurants}

## üéØ EXECUTIVE SUMMARY

${this.generateExecutiveSummary(metrics)}

## üìà PERFORMANCE METRICS

### Response Times:
- **GBGPT Average:** ${metrics.averageGBGPTResponseTime}ms (${(metrics.averageGBGPTResponseTime/1000).toFixed(1)}s)
- **OpenAI Average:** ${metrics.averageOpenAIResponseTime}ms (${(metrics.averageOpenAIResponseTime/1000).toFixed(1)}s)
- **Speed Advantage:** OpenAI –µ ${Math.round(metrics.averageGBGPTResponseTime/metrics.averageOpenAIResponseTime)}x –ø–æ-–±—ä—Ä–∑

### Success Rates:
- **GBGPT Success:** ${metrics.successfulGBGPT}/${metrics.totalRestaurants} (${((metrics.successfulGBGPT/metrics.totalRestaurants)*100).toFixed(1)}%)
- **OpenAI Fallback:** ${metrics.fallbackToOpenAI}/${metrics.totalRestaurants} (${((metrics.fallbackToOpenAI/metrics.totalRestaurants)*100).toFixed(1)}%)
- **Total Failures:** ${metrics.totalFailures}/${metrics.totalRestaurants} (${((metrics.totalFailures/metrics.totalRestaurants)*100).toFixed(1)}%)

## üí∞ COST ANALYSIS

### Per-Request Costs:
- **GBGPT:** ${metrics.costAnalysis.gbgptCostPerRequest} per scoring
- **OpenAI:** ${metrics.costAnalysis.openaiCostPerRequest} per scoring  
- **Cost Savings:** GBGPT –µ ${Math.round((metrics.costAnalysis.openaiCostPerRequest/metrics.costAnalysis.gbgptCostPerRequest)*100)/100}x –ø–æ-–µ–≤—Ç–∏–Ω

### Projected Monthly Costs (1000 restaurants):
- **GBGPT-Only:** ${(metrics.costAnalysis.gbgptCostPerRequest * 1000).toFixed(2)}
- **OpenAI-Only:** ${(metrics.costAnalysis.openaiCostPerRequest * 1000).toFixed(2)}
- **Hybrid (70% GBGPT):** ${((metrics.costAnalysis.gbgptCostPerRequest * 700) + (metrics.costAnalysis.openaiCostPerRequest * 300)).toFixed(2)}

## üéØ QUALITY ASSESSMENT

### Vegan Score Distribution:
${Object.entries(metrics.qualityAnalysis.scoreDistribution)
  .map(([range, count]) => `- **${range}:** ${count} restaurants (${((count/metrics.totalRestaurants)*100).toFixed(1)}%)`)
  .join('\n')}

### Language & Content Quality:
- **Reasoning Quality:** ${metrics.qualityAnalysis.reasoningQuality}
- **Bulgarian Language:** ${metrics.qualityAnalysis.bulgarianLanguageQuality}  
- **Average Vegan Score:** ${metrics.averageVeganScore}/5.0

## üéØ RECOMMENDATIONS

${this.generateRecommendations(metrics)}

## üìã DETAILED RESULTS

### Top 10 Successful Scores:
${results.filter(r => r.success).slice(0, 10).map((r, i) => 
  `${i+1}. **${r.restaurant.name}** - Score: ${r.score?.overallScore}/5 (${r.duration}ms, ${r.provider})`
).join('\n')}

### Failed Restaurants:
${results.filter(r => !r.success).slice(0, 5).map((r, i) =>
  `${i+1}. **${r.restaurant.name}** - Error: ${r.error}`  
).join('\n')}

---

**Test completed at:** ${timestamp}`;
  }

  private static generateExecutiveSummary(metrics: TestMetrics): string {
    const successRate = ((metrics.successfulGBGPT + metrics.fallbackToOpenAI) / metrics.totalRestaurants) * 100;
    
    if (successRate > 90) {
      return "üéâ **EXCELLENT** - System –µ production-ready —Å robust performance";
    } else if (successRate > 75) {
      return "‚úÖ **GOOD** - System —Ä–∞–±–æ—Ç–∏ –¥–æ–±—Ä–µ —Å minor optimizations needed";  
    } else if (successRate > 50) {
      return "‚ö†Ô∏è **FAIR** - System needs significant improvements before production";
    } else {
      return "‚ùå **POOR** - Major issues requiring immediate attention";
    }
  }

  private static generateRecommendations(metrics: TestMetrics): string {
    const recommendations = [];
    
    if (metrics.successfulGBGPT < metrics.fallbackToOpenAI) {
      recommendations.push("- **Use OpenAI as primary** - GBGPT connectivity issues");
    } else {
      recommendations.push("- **Use GBGPT as primary** - Good connectivity –∏ performance");
    }
    
    if (metrics.averageGBGPTResponseTime > 15000) {
      recommendations.push("- **Implement async processing** - GBGPT responses —Å–∞ —Ç–≤—ä—Ä–¥–µ –±–∞–≤–Ω–∏ –∑–∞ real-time");
    }
    
    if (metrics.costAnalysis.gbgptCostPerRequest < metrics.costAnalysis.openaiCostPerRequest) {
      recommendations.push("- **Cost advantage confirmed** - GBGPT –µ –∑–Ω–∞—á–∏—Ç–µ–ª–Ω–æ –ø–æ-–µ–≤—Ç–∏–Ω");
    }
    
    if (metrics.qualityAnalysis.bulgarianLanguageQuality === 'Excellent') {
      recommendations.push("- **Bulgarian optimization success** - GBGPT –µ superior –∑–∞ BG market");
    }
    
    return recommendations.join('\n');
  }
}

/**
 * Enhanced bulk test endpoint with report generation
 */
router.post('/bulk-test-gbgpt-with-report', async (req, res) => {
  try {
    console.log('üöÄ Starting enhanced bulk GBGPT test with comprehensive reporting...');
    
    // [Same restaurant processing logic as above]
    // ... process all 50 restaurants ...
    
    // Generate comprehensive metrics
    const metrics = GBGPTTestReporter.generateReport(results);
    const reportMarkdown = GBGPTTestReporter.generateMarkdownReport(metrics, results);
    
    // Save report to file
    const fs = await import('fs/promises');
    const reportPath = `./reports/gbgpt-test-${Date.now()}.md`;
    
    try {
      await fs.mkdir('./reports', { recursive: true });
      await fs.writeFile(reportPath, reportMarkdown);
      console.log(`üìÑ Report saved to: ${reportPath}`);
    } catch (fileError) {
      console.warn('‚ö†Ô∏è Could not save report file:', fileError.message);
    }

    res.json({
      success: true,
      metrics,
      reportPath,
      reportPreview: reportMarkdown.slice(0, 1000) + '...',
      rawResults: results.slice(0, 5), // Sample results
      message: `Test completed: ${metrics.successfulGBGPT + metrics.fallbackToOpenAI}/${metrics.totalRestaurants} successful`
    });
    
  } catch (error) {
    console.error('‚ùå Enhanced bulk test failed:', error);
    
    res.status(500).json({
      success: false,
      error: error.message,
      message: 'Enhanced bulk test failed'
    });
  }
});
```

---

## –°–¢–™–ü–ö–ê 7: Execute Enhanced Test

### Test Commands:

**1. Health Check –ø—ä—Ä–≤–æ:**
```bash
GET /api/gbgpt-health
```

**2. Run Enhanced Bulk Test:**
```bash
POST /api/bulk-test-gbgpt-with-report
# –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ —â–µ –≥–µ–Ω–µ—Ä–∏—Ä–∞ comprehensive report
```

**3. Review Generated Report:**
```bash
# Check –≤ console logs –∑–∞ report file location
# Report —â–µ –µ saved –≤ ./reports/gbgpt-test-[timestamp].md
```

---

## üìä EXPECTED REPORT CONTENTS

### Performance Section:
- GBGPT vs OpenAI response times (exact milliseconds)
- Success rates –∑–∞ –≤—Å–µ–∫–∏ provider
- Fallback trigger frequency –∏ effectiveness

### Cost Analysis:
- Per-request costs –∑–∞ GBGPT vs OpenAI
- Monthly projections –∑–∞ 1000+ restaurants  
- ROI analysis –∑–∞ choosing GBGPT vs OpenAI

### Quality Assessment:
- Vegan score distribution (—Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–∏ –ª–∏ —Å–∞ scores?)
- Bulgarian language quality evaluation
- Reasoning depth –∏ accuracy analysis

### Strategic Recommendations:
- –ö–æ–π provider –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –∫–∞—Ç–æ primary?
- –ó–∞ –∫–∞–∫–≤–∏ cases –µ optimal GBGPT vs OpenAI?
- Production deployment strategy

---

## üìû EXPECTED OUTCOMES

### Scenario A: GBGPT Works
```
Result: Amazing - –ø—ä—Ä–≤–∏—è AI —Å Bulgarian vegan scoring
Impact: Competitive advantage –∑–∞ –±—ä–ª–≥–∞—Ä—Å–∫–∏ –ø–∞–∑–∞—Ä
Next: Production deployment —Å GBGPT primary
```

### Scenario B: GBGPT Fails, OpenAI Works  
```
Result: Expected fallback behavior confirmed
Impact: Robust system ready –∑–∞ production
Next: Deploy —Å—ä—Å OpenAI, GBGPT –∑–∞ –±—ä–¥–µ—â–µ
```

### Scenario C: Both Fail
```
Result: Need debugging –∏ architecture review
Impact: Hold deployment –¥–æ fix
Next: Technical troubleshooting session
```

**All scenarios —Å–∞ valuable –∑–∞ production readiness!** ‚ú®