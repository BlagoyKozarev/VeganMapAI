// OptimizedLeafletMap.tsx - High-performance map component for 250K+ restaurants
import React, { useEffect, useRef, useState, useCallback } from 'react';
import L from 'leaflet';
import 'leaflet/dist/leaflet.css';
import 'leaflet.markercluster/dist/MarkerCluster.css';
import 'leaflet.markercluster/dist/MarkerCluster.Default.css';
import 'leaflet.markercluster';
import { MapPerformanceManager } from './MapPerformanceManager';

interface Restaurant {
  id: string;
  name: string;
  latitude: number;
  longitude: number;
  veganScore: string;
  cuisineTypes?: string[];
  rating?: number;
  priceLevel?: number;
  address?: string;
}

interface OptimizedLeafletMapProps {
  restaurants: Restaurant[];
  onRestaurantClick?: (restaurant: Restaurant) => void;
  onMapMove?: (bounds: any) => void;
  searchQuery?: string;
  center?: [number, number];
  zoom?: number;
  className?: string;
}

export const OptimizedLeafletMap: React.FC<OptimizedLeafletMapProps> = ({
  restaurants,
  onRestaurantClick,
  onMapMove,
  searchQuery = '',
  center = [42.6977, 23.3219], // Sofia default
  zoom = 12,
  className = ''
}) => {
  const mapRef = useRef<L.Map | null>(null);
  const mapContainerRef = useRef<HTMLDivElement>(null);
  const markerClusterGroupRef = useRef<L.MarkerClusterGroup | null>(null);
  const performanceManagerRef = useRef<MapPerformanceManager | null>(null);
  const currentMarkersRef = useRef<L.Marker[]>([]);
  
  const [isLoading, setIsLoading] = useState(true);
  const [performanceStats, setPerformanceStats] = useState<any>({});
  const [mapReady, setMapReady] = useState(false);

  // Initialize performance manager
  useEffect(() => {
    if (!performanceManagerRef.current) {
      performanceManagerRef.current = new MapPerformanceManager();
    }
  }, []);

  // Initialize map
  useEffect(() => {
    if (!mapContainerRef.current || mapRef.current) return;

    console.log('🗺️ Initializing optimized map...');

    // Create map with optimized settings
    const map = L.map(mapContainerRef.current, {
      center: center,
      zoom: zoom,
      zoomControl: true,
      attributionControl: false,
      preferCanvas: true, // Use canvas for better performance
      maxZoom: 18,
      minZoom: 8
    });

    // Add tile layer
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors',
      maxZoom: 18,
      updateWhenZooming: false, // Performance optimization
      updateWhenIdle: true
    }).addTo(map);

    // Create marker cluster group with optimized settings
    const clusterGroup = L.markerClusterGroup({
      chunkedLoading: true,
      chunkProgress: (processed, total) => {
        console.log(`📍 Loading markers: ${processed}/${total}`);
      },
      maxClusterRadius: 50,
      disableClusteringAtZoom: 16,
      spiderfyOnMaxZoom: true,
      showCoverageOnHover: false,
      zoomToBoundsOnClick: true,
      removeOutsideVisibleBounds: true, // Critical for performance
      iconCreateFunction: (cluster) => {
        const count = cluster.getChildCount();
        let className = 'marker-cluster-small';
        
        if (count > 100) className = 'marker-cluster-large';
        else if (count > 10) className = 'marker-cluster-medium';
        
        return L.divIcon({
          html: `<div><span>${count}</span></div>`,
          className: `marker-cluster ${className}`,
          iconSize: L.point(40, 40)
        });
      }
    });

    map.addLayer(clusterGroup);

    mapRef.current = map;
    markerClusterGroupRef.current = clusterGroup;

    // Set up viewport change handling with throttling
    const handleViewportChange = throttle(() => {
      if (!mapRef.current || !performanceManagerRef.current) return;

      const bounds = mapRef.current.getBounds();
      const zoom = mapRef.current.getZoom();
      
      const viewportBounds = {
        north: bounds.getNorth(),
        south: bounds.getSouth(),
        east: bounds.getEast(),
        west: bounds.getWest(),
        zoom: zoom
      };

      // Update performance manager
      const visibleRestaurants = performanceManagerRef.current.updateViewport(viewportBounds);
      
      // Update markers
      updateMarkers(visibleRestaurants);
      
      // Update stats
      setPerformanceStats(performanceManagerRef.current.getStatistics());
      
      // Callback
      onMapMove?.(viewportBounds);
    }, 300);

    map.on('moveend', handleViewportChange);
    map.on('zoomend', handleViewportChange);

    setMapReady(true);

    return () => {
      if (mapRef.current) {
        mapRef.current.remove();
        mapRef.current = null;
      }
      performanceManagerRef.current?.cleanup();
    };
  }, [center, zoom, onMapMove]);

  // Initialize restaurant dataset
  useEffect(() => {
    if (!performanceManagerRef.current || !restaurants.length) return;

    const initializeData = async () => {
      setIsLoading(true);
      
      try {
        await performanceManagerRef.current!.initializeDataset(restaurants);
        
        // Initial viewport update
        if (mapRef.current) {
          const bounds = mapRef.current.getBounds();
          const zoom = mapRef.current.getZoom();
          
          const viewportBounds = {
            north: bounds.getNorth(),
            south: bounds.getSouth(),
            east: bounds.getEast(),
            west: bounds.getWest(),
            zoom: zoom
          };

          const visibleRestaurants = performanceManagerRef.current!.updateViewport(viewportBounds);
          updateMarkers(visibleRestaurants);
        }
        
        setPerformanceStats(performanceManagerRef.current!.getStatistics());
      } catch (error) {
        console.error('❌ Failed to initialize restaurant data:', error);
      } finally {
        setIsLoading(false);
      }
    };

    initializeData();
  }, [restaurants]);

  // Handle search
  useEffect(() => {
    if (!performanceManagerRef.current || !mapReady) return;

    const searchResults = performanceManagerRef.current.searchInViewport(searchQuery);
    updateMarkers(searchResults);
  }, [searchQuery, mapReady]);

  // Update markers function
  const updateMarkers = useCallback((restaurantsToShow: Restaurant[]) => {
    if (!markerClusterGroupRef.current) return;

    const startTime = performance.now();

    // Clear existing markers
    markerClusterGroupRef.current.clearLayers();
    currentMarkersRef.current = [];

    // Create new markers
    const markers: L.Marker[] = [];
    
    restaurantsToShow.forEach(restaurant => {
      const score = parseFloat(restaurant.veganScore) || 0;
      const scoreColor = getScoreColor(score);
      
      const marker = L.marker([restaurant.latitude, restaurant.longitude], {
        icon: createOptimizedIcon(score, scoreColor)
      });

      // Add popup with restaurant info
      marker.bindPopup(createPopupContent(restaurant), {
        maxWidth: 300,
        className: 'custom-popup'
      });

      // Click handler
      marker.on('click', () => {
        onRestaurantClick?.(restaurant);
      });

      markers.push(marker);
    });

    // Add markers to cluster group in batches for better performance
    const batchSize = 500;
    for (let i = 0; i < markers.length; i += batchSize) {
      const batch = markers.slice(i, i + batchSize);
      markerClusterGroupRef.current.addLayers(batch);
    }

    currentMarkersRef.current = markers;

    const renderTime = performance.now() - startTime;
    console.log(`✅ Rendered ${markers.length} markers in ${renderTime.toFixed(2)}ms`);
  }, [onRestaurantClick]);

  // Create optimized marker icon
  const createOptimizedIcon = (score: number, color: string): L.DivIcon => {
    return L.divIcon({
      className: 'custom-marker',
      html: `
        <div class="marker-pin" style="background-color: ${color};">
          <span class="marker-score">${score.toFixed(1)}</span>
        </div>
      `,
      iconSize: [30, 30],
      iconAnchor: [15, 30],
      popupAnchor: [0, -30]
    });
  };

  // Get color based on vegan score
  const getScoreColor = (score: number): string => {
    if (score >= 4) return '#22c55e'; // Green
    if (score >= 3) return '#eab308'; // Yellow
    if (score >= 2) return '#f97316'; // Orange
    return '#ef4444'; // Red
  };

  // Create popup content
  const createPopupContent = (restaurant: Restaurant): string => {
    const score = parseFloat(restaurant.veganScore) || 0;
    const stars = '★'.repeat(Math.round(score)) + '☆'.repeat(5 - Math.round(score));
    
    return `
      <div class="restaurant-popup">
        <h3 class="popup-title">${restaurant.name}</h3>
        <div class="popup-score">
          <span class="stars">${stars}</span>
          <span class="score-value">${score.toFixed(1)}/5</span>
        </div>
        ${restaurant.cuisineTypes?.length ? 
          `<div class="popup-cuisine">${restaurant.cuisineTypes.join(', ')}</div>` : ''
        }
        ${restaurant.address ? 
          `<div class="popup-address">${restaurant.address}</div>` : ''
        }
      </div>
    `;
  };

  // Throttle function for performance
  function throttle<T extends (...args: any[]) => any>(
    func: T,
    limit: number
  ): (...args: Parameters<T>) => void {
    let inThrottle: boolean;
    return (...args: Parameters<T>) => {
      if (!inThrottle) {
        func.apply(null, args);
        inThrottle = true;
        setTimeout(() => (inThrottle = false), limit);
      }
    };
  }

  return (
    <div className={`relative w-full h-full ${className}`}>
      {/* Map container */}
      <div
        ref={mapContainerRef}
        className="w-full h-full"
        style={{ minHeight: '400px' }}
      />

      {/* Loading overlay */}
      {isLoading && (
        <div className="absolute inset-0 bg-white bg-opacity-75 flex items-center justify-center z-[1000]">
          <div className="text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-green-600 mx-auto mb-4"></div>
            <p className="text-lg font-medium">Loading restaurants...</p>
            <p className="text-sm text-gray-600">Optimizing for {restaurants.length.toLocaleString()} locations</p>
          </div>
        </div>
      )}

      {/* Performance stats overlay (development) */}
      {process.env.NODE_ENV === 'development' && Object.keys(performanceStats).length > 0 && (
        <div className="absolute top-4 right-4 bg-black bg-opacity-75 text-white p-3 rounded-lg text-xs z-[1000]">
          <div className="font-bold mb-2">Performance Stats</div>
          <div>Total: {performanceStats.totalRestaurants?.toLocaleString()}</div>
          <div>Visible: {performanceStats.visibleRestaurants?.toLocaleString()}</div>
          <div>Memory: {performanceStats.memoryEstimate}</div>
          <div>Markers: {currentMarkersRef.current.length}</div>
        </div>
      )}

      {/* Custom styles */}
      <style jsx global>{`
        .marker-cluster {
          background-color: #3b82f6;
          border: 2px solid #ffffff;
          border-radius: 50%;
          color: white;
          font-weight: bold;
          text-align: center;
          font-size: 12px;
          display: flex;
          align-items: center;
          justify-content: center;
        }

        .marker-cluster-small {
          background-color: #10b981;
        }

        .marker-cluster-medium {
          background-color: #f59e0b;
        }

        .marker-cluster-large {
          background-color: #ef4444;
        }

        .custom-marker {
          background: none;
          border: none;
        }

        .marker-pin {
          width: 24px;
          height: 24px;
          border-radius: 50%;
          border: 2px solid white;
          display: flex;
          align-items: center;
          justify-content: center;
          color: white;
          font-weight: bold;
          font-size: 10px;
          box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .restaurant-popup {
          min-width: 200px;
        }

        .popup-title {
          font-size: 16px;
          font-weight: bold;
          margin: 0 0 8px 0;
          color: #1f2937;
        }

        .popup-score {
          display: flex;
          align-items: center;
          gap: 8px;
          margin-bottom: 8px;
        }

        .stars {
          color: #fbbf24;
          font-size: 14px;
        }

        .score-value {
          font-weight: bold;
          color: #059669;
        }

        .popup-cuisine {
          font-size: 12px;
          color: #6b7280;
          margin-bottom: 4px;
        }

        .popup-address {
          font-size: 11px;
          color: #9ca3af;
        }

        .custom-popup .leaflet-popup-content-wrapper {
          border-radius: 8px;
          box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
      `}</style>
    </div>
  );
};