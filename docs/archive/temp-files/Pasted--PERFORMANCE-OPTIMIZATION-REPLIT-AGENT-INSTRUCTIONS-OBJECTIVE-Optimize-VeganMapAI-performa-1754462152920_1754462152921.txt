# ⚡ PERFORMANCE OPTIMIZATION - REPLIT AGENT INSTRUCTIONS

## OBJECTIVE

Optimize VeganMapAI performance to reduce loading times and improve mobile experience based on external analysis feedback.

## CURRENT PROBLEMS

- Map loads slowly with 408 restaurants
- Mobile devices experience lag during zoom/pan
- Search and AI responses have delays
- Browser memory usage could be optimized

## IMPLEMENTATION PLAN

### STEP 1: Map Performance Optimization (45 min)

**1.1 Optimize Leaflet Clustering Settings**

**File to modify: `client/src/components/Map.tsx` (or similar map component)**

```typescript
// Find current markercluster configuration and update:

import L from 'leaflet';
import 'leaflet.markercluster';

// OPTIMIZED CLUSTERING CONFIG
const clusterOptions = {
  // Increase cluster radius for better performance
  maxClusterRadius: 50,
  
  // Reduce animation time for faster interactions
  animateAddingMarkers: false,
  
  // Optimize for mobile performance
  spiderfyOnMaxZoom: false,
  showCoverageOnHover: false,
  
  // Custom cluster icon for better performance
  iconCreateFunction: function(cluster) {
    const count = cluster.getChildCount();
    const size = count < 10 ? 'small' : count < 100 ? 'medium' : 'large';
    
    return L.divIcon({
      html: `<div class="cluster-marker cluster-${size}">${count}</div>`,
      className: 'cluster-icon',
      iconSize: [40, 40]
    });
  }
};

// Apply clustering with optimization
const markerCluster = L.markerClusterGroup(clusterOptions);
```

**1.2 Implement Viewport-Based Loading**

```typescript
// Add viewport-based restaurant loading
const [viewportBounds, setViewportBounds] = useState(null);
const [visibleRestaurants, setVisibleRestaurants] = useState([]);

const updateVisibleRestaurants = useCallback((bounds) => {
  const filtered = restaurants.filter(restaurant => {
    const lat = parseFloat(restaurant.latitude);
    const lng = parseFloat(restaurant.longitude);
    
    return bounds.contains([lat, lng]);
  });
  
  setVisibleRestaurants(filtered);
}, [restaurants]);

// Add map event listener
useEffect(() => {
  if (map) {
    const handleMoveEnd = () => {
      const bounds = map.getBounds();
      setViewportBounds(bounds);
      updateVisibleRestaurants(bounds);
    };
    
    map.on('moveend', handleMoveEnd);
    map.on('zoomend', handleMoveEnd);
    
    // Initial load
    handleMoveEnd();
    
    return () => {
      map.off('moveend', handleMoveEnd);
      map.off('zoomend', handleMoveEnd);
    };
  }
}, [map, updateVisibleRestaurants]);
```

**1.3 Add CSS for Optimized Clusters**

```css
/* Add to your main CSS file */
.cluster-icon {
  background: none !important;
  border: none !important;
}

.cluster-marker {
  background: #3B82F6;
  color: white;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-size: 12px;
  border: 2px solid white;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.cluster-small { width: 30px; height: 30px; font-size: 11px; }
.cluster-medium { width: 40px; height: 40px; font-size: 12px; }
.cluster-large { width: 50px; height: 50px; font-size: 14px; }
```

### STEP 2: Database Query Optimization (30 min)

**2.1 Optimize Restaurant API Endpoint**

**File to modify: `server/routes/restaurants.ts` (or similar)**

```typescript
// Add database indexing and query optimization

// BEFORE - might load all data:
const restaurants = await db.select().from(restaurantsTable);

// AFTER - optimized with bounds and pagination:
export async function getRestaurantsInBounds(bounds: {
  north: number, south: number, east: number, west: number
}, limit: number = 200) {
  
  const restaurants = await db
    .select({
      id: restaurantsTable.id,
      name: restaurantsTable.name,
      latitude: restaurantsTable.latitude,
      longitude: restaurantsTable.longitude,
      veganScore: restaurantsTable.veganScore,
      cuisineTypes: restaurantsTable.cuisineTypes,
      address: restaurantsTable.address,
      // Only select essential fields for map display
    })
    .from(restaurantsTable)
    .where(
      and(
        gte(restaurantsTable.latitude, bounds.south),
        lte(restaurantsTable.latitude, bounds.north),
        gte(restaurantsTable.longitude, bounds.west),
        lte(restaurantsTable.longitude, bounds.east)
      )
    )
    .limit(limit)
    .orderBy(desc(restaurantsTable.veganScore)); // Show best restaurants first
  
  return restaurants;
}

// Update API endpoint to use bounds-based loading
app.get('/api/restaurants/map-data', async (req, res) => {
  const { north, south, east, west, limit } = req.query;
  
  if (north && south && east && west) {
    const bounds = {
      north: parseFloat(north as string),
      south: parseFloat(south as string), 
      east: parseFloat(east as string),
      west: parseFloat(west as string)
    };
    
    const restaurants = await getRestaurantsInBounds(bounds, parseInt(limit as string) || 200);
    return res.json(restaurants);
  }
  
  // Fallback to all restaurants if no bounds provided
  const allRestaurants = await db.select().from(restaurantsTable).limit(500);
  res.json(allRestaurants);
});
```

**2.2 Add Database Indexes (if not present)**

```sql
-- Run this in your database to optimize queries:

CREATE INDEX IF NOT EXISTS idx_restaurants_location 
ON restaurants (latitude, longitude);

CREATE INDEX IF NOT EXISTS idx_restaurants_vegan_score 
ON restaurants (vegan_score DESC);

CREATE INDEX IF NOT EXISTS idx_restaurants_cuisine 
ON restaurants USING gin(cuisine_types);
```

### STEP 3: React Component Optimization (30 min)

**3.1 Implement React.memo and useMemo**

```typescript
// Optimize restaurant components with memoization

import React, { memo, useMemo } from 'react';

// Memoize expensive components
const RestaurantMarker = memo(({ restaurant, onClick }) => {
  const markerIcon = useMemo(() => {
    return L.divIcon({
      html: `<div class="restaurant-marker score-${Math.floor(restaurant.veganScore)}">${restaurant.veganScore}</div>`,
      className: 'custom-marker',
      iconSize: [30, 30]
    });
  }, [restaurant.veganScore]);
  
  return (
    <Marker 
      position={[restaurant.latitude, restaurant.longitude]}
      icon={markerIcon}
      eventHandlers={{ click: onClick }}
    />
  );
});

// Optimize restaurant list rendering
const RestaurantList = memo(({ restaurants, onRestaurantSelect }) => {
  const sortedRestaurants = useMemo(() => {
    return restaurants
      .slice()
      .sort((a, b) => parseFloat(b.veganScore) - parseFloat(a.veganScore));
  }, [restaurants]);
  
  return (
    <div className="restaurant-list">
      {sortedRestaurants.map(restaurant => (
        <RestaurantCard 
          key={restaurant.id} 
          restaurant={restaurant}
          onSelect={onRestaurantSelect}
        />
      ))}
    </div>
  );
});
```

**3.2 Implement Lazy Loading for Components**

```typescript
// Lazy load heavy components
import { lazy, Suspense } from 'react';

const LazyRestaurantDetails = lazy(() => import('./RestaurantDetails'));
const LazyVoiceSearch = lazy(() => import('./VoiceSearch'));

// Use with Suspense
<Suspense fallback={<div className="loading-spinner">Loading...</div>}>
  <LazyRestaurantDetails restaurant={selectedRestaurant} />
</Suspense>
```

### STEP 4: API Response Optimization (15 min)

**4.1 Add Response Compression**

```typescript
// In your Express server setup
import compression from 'compression';

app.use(compression()); // Gzip compression for all responses

// Optimize JSON responses
app.use(express.json({ limit: '1mb' }));

// Add caching headers
app.use('/api', (req, res, next) => {
  if (req.method === 'GET') {
    res.set('Cache-Control', 'public, max-age=300'); // 5 minutes cache
  }
  next();
});
```

**4.2 Optimize Search API Response**

```typescript
// Make search responses smaller and faster
export async function searchRestaurants(query: string, limit: number = 20) {
  const results = await db
    .select({
      id: restaurantsTable.id,
      name: restaurantsTable.name,
      veganScore: restaurantsTable.veganScore,
      cuisineTypes: restaurantsTable.cuisineTypes,
      latitude: restaurantsTable.latitude,
      longitude: restaurantsTable.longitude
      // Don't send full restaurant data for search results
    })
    .from(restaurantsTable)
    .where(
      or(
        ilike(restaurantsTable.name, `%${query}%`),
        // Add other search conditions
      )
    )
    .limit(limit)
    .orderBy(desc(restaurantsTable.veganScore));
  
  return results;
}
```

## STEP 5: Testing Performance Improvements (20 min)

**5.1 Performance Testing Checklist**

```bash
# 1. Start development server
npm run dev

# 2. Open browser Developer Tools (F12)
# 3. Go to Performance tab
# 4. Record while:
#    - Loading the map
#    - Zooming in/out multiple times
#    - Searching for restaurants
#    - Clicking on multiple markers

# 5. Check improvements in:
#    - Initial page load time
#    - Map interaction responsiveness
#    - Search response time
#    - Memory usage (check Memory tab)

# 6. Mobile testing:
#    - Use Chrome Device Emulation
#    - Test on actual mobile device if possible
#    - Check touch response times
```

**5.2 Performance Benchmarks to Achieve**

```
BEFORE vs AFTER targets:

Initial map load: 3-5s → <2s
Search response: 2-3s → <1s
Zoom/pan response: 500ms → <200ms
Memory usage: 150MB+ → <100MB
Mobile interactions: laggy → smooth
```

## EXPECTED RESULTS

### Map Performance:

- ✅ Faster initial loading with optimized clustering
- ✅ Smooth zoom/pan on mobile devices
- ✅ Reduced memory usage
- ✅ Better responsiveness on slower devices

### API Performance:

- ✅ Faster search results
- ✅ Reduced data transfer
- ✅ Better caching
- ✅ Optimized database queries

### User Experience:

- ✅ No lag during map interactions
- ✅ Instant search results
- ✅ Smooth mobile experience
- ✅ Professional-feeling responsiveness

## SUCCESS CRITERIA

✅ **Load Time**: Map loads in <2 seconds
✅ **Responsiveness**: Touch/click responses in <200ms  
✅ **Search Speed**: Results appear in <1 second
✅ **Mobile Performance**: Smooth on iPhone/Android
✅ **Memory Usage**: <100MB browser memory
✅ **No Lag**: Smooth zoom/pan at all zoom levels

## ESTIMATED TIME: 2.5 hours total

These performance improvements will address the speed and responsiveness issues identified in both external analyses, making VeganMapAI feel professional and fast!