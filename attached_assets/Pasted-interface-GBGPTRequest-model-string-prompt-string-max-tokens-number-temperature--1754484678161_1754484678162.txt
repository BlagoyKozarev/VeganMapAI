interface GBGPTRequest {
  model: string;
  prompt: string;
  max_tokens: number;
  temperature: number;
  top_p?: number;
}

interface GBGPTResponse {
  choices: Array<{
    text: string;
    index: number;
    finish_reason: string;
  }>;
  usage?: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}

export class GBGPTProvider {
  private apiUrl: string;
  private apiKey: string;
  private timeout: number;

  constructor() {
    this.apiUrl = process.env.GBGPT_API_URL || 'http://192.168.0.245:5000/v1/completions';
    this.apiKey = process.env.GBGPT_API_KEY || 'R@icommerce23';
    this.timeout = 20000; // 20 —Å–µ–∫—É–Ω–¥–∏ - GBGPT –µ –±–∞–≤–µ–Ω!
  }

  /**
   * Score restaurant using GBGPT - BG language optimized
   */
  async scoreRestaurant(restaurantData: any): Promise<any> {
    console.log(`üîÑ GBGPT scoring restaurant: ${restaurantData.name} (–º–æ–∂–µ –¥–∞ –æ—Ç–Ω–µ–º–µ 10-15 —Å–µ–∫)`);
    
    const prompt = this.createScoringPrompt(restaurantData);
    
    try {
      const response = await this.makeRequest({
        model: "gpt-3.5-turbo",
        prompt,
        max_tokens: 600,
        temperature: 0.2,
        top_p: 0.9
      });

      return this.parseScoringResponse(response);
      
    } catch (error) {
      console.error('‚ùå GBGPT scoring failed:', error.message);
      throw error;
    }
  }

  /**
   * Core API request method with robust error handling
   */
  private async makeRequest(payload: GBGPTRequest): Promise<string> {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);

    try {
      console.log('üì° Making GBGPT API request... (–º–æ–∂–µ –¥–∞ –æ—Ç–Ω–µ–º–µ –≤—Ä–µ–º–µ)');
      
      const response = await fetch(this.apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`,
          'User-Agent': 'VeganMapAI/1.0'
        },
        body: JSON.stringify(payload),
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`GBGPT API Error ${response.status}: ${errorText}`);
      }

      const data: GBGPTResponse = await response.json();
      
      if (!data.choices || data.choices.length === 0) {
        throw new Error('GBGPT returned no choices');
      }

      return data.choices[0].text.trim();
      
    } catch (error) {
      clearTimeout(timeoutId);
      
      if (error.name === 'AbortError') {
        throw new Error(`GBGPT timeout after ${this.timeout/1000}s - server is slow`);
      }
      
      throw error;
    }
  }

  /**
   * Create scoring prompt in Bulgarian for better GBGPT understanding
   */
  private createScoringPrompt(restaurant: any): string {
    return `–ê–Ω–∞–ª–∏–∑–∏—Ä–∞–π —Ç–æ–∑–∏ —Ä–µ—Å—Ç–æ—Ä–∞–Ω—Ç –∑–∞ vegan-friendliness –∏ –≤—ä—Ä–Ω–∏ –°–ê–ú–û JSON:

–†–µ—Å—Ç–æ—Ä–∞–Ω—Ç: ${restaurant.name}
–ê–¥—Ä–µ—Å: ${restaurant.address || '–ù–µ–∏–∑–≤–µ—Å—Ç–µ–Ω'}
–¢–∏–ø –∫—É—Ö–Ω—è: ${restaurant.cuisineTypes?.join(', ') || '–ù–µ–∏–∑–≤–µ—Å—Ç–µ–Ω'}
–û—Ç–∑–∏–≤–∏: ${restaurant.reviews?.slice(0, 3)?.map(r => r.text)?.join(' | ') || '–ù—è–º–∞ –æ—Ç–∑–∏–≤–∏'}

–í—ä—Ä–Ω–∏ —Ç–æ—á–Ω–æ —Ç–æ–∑–∏ JSON —Ñ–æ—Ä–º–∞—Ç (–±–µ–∑ –¥–æ–ø—ä–ª–Ω–∏—Ç–µ–ª–µ–Ω —Ç–µ–∫—Å—Ç):
{
  "menuVariety": [—á–∏—Å–ª–æ 1-10],
  "ingredientClarity": [—á–∏—Å–ª–æ 1-10], 
  "staffKnowledge": [—á–∏—Å–ª–æ 1-10],
  "crossContamination": [—á–∏—Å–ª–æ 1-10],
  "nutritionalInfo": [—á–∏—Å–ª–æ 1-10],
  "allergenManagement": [—á–∏—Å–ª–æ 1-10],
  "reasoning": "–∫—Ä–∞—Ç–∫–æ –æ–±—è—Å–Ω–µ–Ω–∏–µ –Ω–∞ –±—ä–ª–≥–∞—Ä—Å–∫–∏",
  "confidence": [—á–∏—Å–ª–æ 0.1-1.0]
}`;
  }

  /**
   * Parse GBGPT response and convert to VeganMapAI format
   */
  private parseScoringResponse(response: string): any {
    try {
      // Try to parse JSON from response
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        throw new Error('No JSON found in GBGPT response');
      }

      const parsed = JSON.parse(jsonMatch[0]);
      
      // Convert to VeganMapAI format
      const totalScore = (
        parsed.menuVariety +
        parsed.ingredientClarity +
        parsed.staffKnowledge +
        parsed.crossContamination +
        parsed.nutritionalInfo +
        parsed.allergenManagement
      ) / 6;

      return {
        overallScore: Math.round((totalScore / 10) * 5 * 10) / 10, // Convert to 1-5 scale
        dimensions: {
          menuVariety: parsed.menuVariety,
          ingredientClarity: parsed.ingredientClarity,
          staffKnowledge: parsed.staffKnowledge,
          crossContamination: parsed.crossContamination,
          nutritionalInfo: parsed.nutritionalInfo,
          allergenManagement: parsed.allergenManagement
        },
        reasoning: parsed.reasoning,
        confidence: parsed.confidence || 0.5,
        provider: 'GBGPT',
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      console.error('‚ùå Failed to parse GBGPT response:', error);
      throw new Error('Invalid GBGPT response format');
    }
  }

  /**
   * Health check for GBGPT connectivity
   */
  async healthCheck(): Promise<boolean> {
    try {
      const testResponse = await this.makeRequest({
        model: "gpt-3.5-turbo",
        prompt: "Respond with: OK",
        max_tokens: 10,
        temperature: 0
      });

      return testResponse.toLowerCase().includes('ok');
      
    } catch (error) {
      console.error('‚ùå GBGPT health check failed:', error);
      return false;
    }
  }
}