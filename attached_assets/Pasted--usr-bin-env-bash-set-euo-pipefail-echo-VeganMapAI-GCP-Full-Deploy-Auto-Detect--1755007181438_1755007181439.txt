#!/usr/bin/env bash
set -euo pipefail

echo "=== VeganMapAI ¬∑ GCP Full Deploy (Auto-Detect) ==="

# -------------------------
# 0) –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª–Ω–∏ –ø—Ä–æ–≤–µ—Ä–∫–∏
# -------------------------
need() { command -v "$1" >/dev/null 2>&1 || { echo "‚ùå Missing: $1"; exit 1; }; }
need jq || true  # jq –µ —Å–∏–ª–Ω–æ –ø—Ä–µ–ø–æ—Ä—ä—á–∏—Ç–µ–ª–µ–Ω, –Ω–æ –Ω–µ –∫—Ä–∏—Ç–∏—á–µ–Ω
need curl
need sed
need awk
need grep
need gsutil
need gcloud || true  # –∑–∞ Cloud Run —ä–ø–¥–µ–π—Ç (–∞–∫–æ –µ –Ω–∞–ª–∏—á–µ–Ω)

ROOT_DIR="$(pwd)"
ENV_LOCAL="$ROOT_DIR/.env.local"
ENV_PROD="$ROOT_DIR/.env.production"
DATA_DIR="$ROOT_DIR/data/geojson"
mkdir -p "$DATA_DIR"

# -------------------------
# 1) –ó–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
# -------------------------
get_env_val() {
  local file="$1"; local key="$2"
  if [[ -f "$file" ]]; then
    grep -E "^${key}=" "$file" | tail -1 | cut -d'=' -f2- || true
  fi
}

# –ß–µ—Ç–µ–º –æ—Ç .env.production (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç) –∏ .env.local
NEXT_PUBLIC_API_BASE="$(get_env_val "$ENV_PROD" "NEXT_PUBLIC_API_BASE")"
[[ -z "${NEXT_PUBLIC_API_BASE:-}" ]] && NEXT_PUBLIC_API_BASE="$(get_env_val "$ENV_LOCAL" "NEXT_PUBLIC_API_BASE")"

NEXT_PUBLIC_CDN_GEOJSON="$(get_env_val "$ENV_PROD" "NEXT_PUBLIC_CDN_GEOJSON")"
[[ -z "${NEXT_PUBLIC_CDN_GEOJSON:-}" ]] && NEXT_PUBLIC_CDN_GEOJSON="$(get_env_val "$ENV_LOCAL" "NEXT_PUBLIC_CDN_GEOJSON")"

# –ê–∫–æ –∏–º–∞ Cloud Run service/region –æ–ø–∏—Å–∞–Ω–∏ –ª–æ–∫–∞–ª–Ω–æ
CLOUD_RUN_SERVICE="$(get_env_val "$ENV_PROD" "CLOUD_RUN_SERVICE")"
[[ -z "${CLOUD_RUN_SERVICE:-}" ]] && CLOUD_RUN_SERVICE="$(get_env_val "$ENV_LOCAL" "CLOUD_RUN_SERVICE")"
CLOUD_RUN_REGION="$(get_env_val "$ENV_PROD" "CLOUD_RUN_REGION")"
[[ -z "${CLOUD_RUN_REGION:-}" ]] && CLOUD_RUN_REGION="$(get_env_val "$ENV_LOCAL" "CLOUD_RUN_REGION")"

# -------------------------
# 2) –û—Ç–∫—Ä–∏–≤–∞–Ω–µ –Ω–∞ bucket –∏ —Ñ–æ—Ä–º–∏—Ä–∞–Ω–µ –Ω–∞ CDN URL
# -------------------------
# –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 1: –≤–µ—á–µ –∏–∑–≤–µ—Å—Ç–µ–Ω CDN URL => –∏–∑–≤–ª–∏—á–∞–º–µ bucket
extract_bucket_from_url() {
  local url="$1"
  # –ø–æ–¥–¥—ä—Ä–∂–∞ –∏ –¥–≤–µ—Ç–µ —Ñ–æ—Ä–º–∏: storage.googleapis.com/<bucket>/... –∏–ª–∏ https://<bucket>.storage.googleapis.com/...
  if [[ "$url" =~ storage.googleapis.com/([^/]+)/ ]]; then
    echo "${BASH_REMATCH[1]}"
  elif [[ "$url" =~ https://([^\.]+)\.storage\.googleapis\.com/ ]]; then
    echo "${BASH_REMATCH[1]}"
  else
    echo ""
  fi
}

BUCKET_NAME=""
if [[ -n "${NEXT_PUBLIC_CDN_GEOJSON:-}" ]]; then
  BUCKET_NAME="$(extract_bucket_from_url "$NEXT_PUBLIC_CDN_GEOJSON")"
fi

# –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 2: —Ç—ä—Ä—Å–∏–º bucket —Å—ä—Å —à–∞–±–ª–æ–Ω "veganmapai" (–∏–ª–∏ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω –Ω–∞–ª–∏—á–µ–Ω)
if [[ -z "$BUCKET_NAME" ]]; then
  echo "üîé Detecting GCS buckets..."
  if gsutil ls >/dev/null 2>&1; then
    CANDIDATES="$(gsutil ls 2>/dev/null | sed 's@gs://@@;s@/@@g' | grep -i 'veganmapai' || true)"
    if [[ -z "$CANDIDATES" ]]; then
      # fallback: –∞–∫–æ –∏–º–∞ —Å–∞–º–æ 1 bucket ‚Äî –≤–∑–µ–º–∏ –Ω–µ–≥–æ
      ONLY_ONE="$(gsutil ls 2>/dev/null | sed 's@gs://@@;s@/@@g' | wc -l | tr -d ' ')"
      if [[ "$ONLY_ONE" == "1" ]]; then
        BUCKET_NAME="$(gsutil ls 2>/dev/null | sed 's@gs://@@;s@/@@g')"
      fi
    else
      # –ø—Ä–µ–¥–ø–æ—á–µ—Ç–∏ bucket –≤–∫–ª—é—á–≤–∞—â "cdn"
      CDN_MATCH="$(echo "$CANDIDATES" | grep -i 'cdn' || true)"
      if [[ -n "$CDN_MATCH" ]]; then
        BUCKET_NAME="$(echo "$CDN_MATCH" | head -1)"
      else
        BUCKET_NAME="$(echo "$CANDIDATES" | head -1)"
      fi
    fi
  fi
fi

if [[ -z "$BUCKET_NAME" ]]; then
  echo "‚ùå –ù–µ —É—Å–ø—è—Ö –¥–∞ –æ—Ç–∫—Ä–∏—è GCS bucket. –ó–∞–¥–∞–π —Ä—ä—á–Ω–æ BUCKET_NAME –∏ —Å—Ç–∞—Ä—Ç–∏—Ä–∞–π –ø–∞–∫."
  exit 1
fi

CDN_BASE="https://storage.googleapis.com/$BUCKET_NAME"
GEOJSON_PATH="geojson/sofia.geojson"
CDN_GEOJSON_URL="$CDN_BASE/$GEOJSON_PATH"
echo "üß≠ Using bucket: $BUCKET_NAME"
echo "üß≠ Target CDN file: $CDN_GEOJSON_URL"

# -------------------------
# 3) –ï–∫—Å–ø–æ—Ä—Ç –∫—ä–º GeoJSON
# -------------------------
# –û–ø–∏—Ç 1: –ª–æ–∫–∞–ª–µ–Ω backend
LOCAL_EXPORT_URL="http://localhost:5000/map-data?format=geojson"
# –û–ø–∏—Ç 2: –ø—É–±–ª–∏—á–µ–Ω API base (–∞–∫–æ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞)
REMOTE_EXPORT_URL=""
if [[ -n "${NEXT_PUBLIC_API_BASE:-}" ]]; then
  # –¥–æ–ø—É—Å–∫–∞–º–µ /api –∏–ª–∏ –±–µ–∑ /api. –ü–æ–¥–¥—ä—Ä–∂–∞–º–µ /map-data –∫–∞—Ç–æ –µ–Ω–¥–ø–æ–π–Ω—Ç
  REMOTE_EXPORT_URL="${NEXT_PUBLIC_API_BASE%/}/map-data?format=geojson"
fi

OUT_RAW="$DATA_DIR/sofia_raw.json"
OUT_GEOJSON="$DATA_DIR/sofia.geojson"

echo "üì§ Exporting data to GeoJSON..."
set +e
HTTP_CODE_LOCAL=$(curl -s -o "$OUT_GEOJSON" -w "%{http_code}" "$LOCAL_EXPORT_URL")
set -e

if [[ "$HTTP_CODE_LOCAL" != "200" ]]; then
  if [[ -n "$REMOTE_EXPORT_URL" ]]; then
    echo "‚ö†Ô∏è Local export failed ($HTTP_CODE_LOCAL). Trying remote: $REMOTE_EXPORT_URL"
    curl -s "$REMOTE_EXPORT_URL" -o "$OUT_GEOJSON"
  else
    echo "‚ùå –ù—è–º–∞ –¥–æ—Å—Ç—ä–ø–µ–Ω export endpoint (local/remote)."
    exit 1
  fi
fi

# –ë–∞–∑–æ–≤–∞ –≤–∞–ª–∏–¥–∞—Ü–∏—è (GeoJSON FeatureCollection)
if ! grep -q '"FeatureCollection"' "$OUT_GEOJSON"; then
  echo "‚ùå –ò–∑–≥–ª–µ–∂–¥–∞ —Ñ–∞–π–ª—ä—Ç –Ω–µ –µ –≤–∞–ª–∏–¥–µ–Ω GeoJSON FeatureCollection."
  head -c 500 "$OUT_GEOJSON" || true
  exit 1
fi
COUNT_FEATURES="$(grep -o '"type"[[:space:]]*:[[:space:]]*"Feature"' "$OUT_GEOJSON" | wc -l | tr -d ' ')"
echo "‚úÖ GeoJSON OK ¬∑ features: $COUNT_FEATURES"

# -------------------------
# 4) –ö–∞—á–≤–∞–Ω–µ –∫—ä–º GCS (Cache-Control headers)
# -------------------------
echo "‚òÅÔ∏è Uploading to GCS with optimal caching..."
# 1 –¥–µ–Ω –∫–µ—à + immutable (—Å–º–µ–Ω—è–º–µ —Ñ–∞–π–ª–∞ –ø—Ä–∏ –ø—Ä–æ–º—è–Ω–∞ => –Ω–æ–≤–∞ –≤–µ—Ä—Å–∏—è overwrite –µ –æ–∫)
gsutil -h "Cache-Control:public,max-age=86400,immutable" cp "$OUT_GEOJSON" "gs://$BUCKET_NAME/$GEOJSON_PATH"

# -------------------------
# 5) –û–±–Ω–æ–≤—è–≤–∞–Ω–µ –Ω–∞ .env —Ñ–∞–π–ª–æ–≤–µ—Ç–µ —Å –Ω–æ–≤–∏—è CDN_GEOJSON
# -------------------------
upsert_env() {
  local file="$1"; local key="$2"; local val="$3"
  touch "$file"
  if grep -qE "^${key}=" "$file"; then
    # inplace update
    sed -i "s|^${key}=.*|${key}=${val}|" "$file"
  else
    echo "${key}=${val}" >> "$file"
  fi
}

echo "üìù Updating env files with NEXT_PUBLIC_CDN_GEOJSON=$CDN_GEOJSON_URL"
upsert_env "$ENV_LOCAL" "NEXT_PUBLIC_CDN_GEOJSON" "$CDN_GEOJSON_URL"
upsert_env "$ENV_PROD"  "NEXT_PUBLIC_CDN_GEOJSON" "$CDN_GEOJSON_URL"

# -------------------------
# 6) (–û–ø—Ü–∏–æ–Ω–∞–ª–Ω–æ) Cloud Run env update
# -------------------------
if command -v gcloud >/dev/null 2>&1 && [[ -n "${CLOUD_RUN_SERVICE:-}" && -n "${CLOUD_RUN_REGION:-}" ]]; then
  echo "üöÄ Updating Cloud Run env: $CLOUD_RUN_SERVICE ($CLOUD_RUN_REGION)"
  gcloud run services update "$CLOUD_RUN_SERVICE" \
    --update-env-vars "NEXT_PUBLIC_CDN_GEOJSON=$CDN_GEOJSON_URL" \
    --region="$CLOUD_RUN_REGION"
else
  echo "‚ÑπÔ∏è Cloud Run update skipped (missing gcloud or CLOUD_RUN_SERVICE/REGION)."
fi

# -------------------------
# 7) Smoke —Ç–µ—Å—Ç–æ–≤–µ
# -------------------------
echo "üîé Smoke Test #1: HEAD CDN"
curl -I "$CDN_GEOJSON_URL" | sed -n '1,10p'

# –¢–µ—Å—Ç–≤–∞–º–µ /recommend ‚Äî –ø–æ–¥–¥—ä—Ä–∂–∞–º–µ –¥–≤–∞ —Ä–µ–∂–∏–º–∞:
# A) JSON —Ç—è–ª–æ —Å file URL (–∫–∞–∫—Ç–æ –≤–µ—á–µ —Ä–∞–±–æ—Ç–∏)
# B) multipart —Å file=@ (–∞–∫–æ –±–µ–∫–µ–Ω–¥—ä—Ç –≥–æ –ø–æ–¥–¥—ä—Ä–∂–∞)
RECOMMEND_URL_LOCAL="http://localhost:5000/api/recommend"
RECOMMEND_URL_REMOTE=""
if [[ -n "${NEXT_PUBLIC_API_BASE:-}" ]]; then
  RECOMMEND_URL_REMOTE="${NEXT_PUBLIC_API_BASE%/}/api/recommend"
fi

echo "üîé Smoke Test #2: /recommend with file URL (JSON)"
if curl -s -X POST "$RECOMMEND_URL_LOCAL" -H "Content-Type: application/json" \
  -d "{\"lat\":42.6977,\"lng\":23.3219,\"radius\":5000,\"minScore\":0,\"file\":\"$CDN_GEOJSON_URL\"}" \
  | head -c 400 >/dev/null 2>&1; then
  curl -s -X POST "$RECOMMEND_URL_LOCAL" -H "Content-Type: application/json" \
    -d "{\"lat\":42.6977,\"lng\":23.3219,\"radius\":5000,\"minScore\":0,\"file\":\"$CDN_GEOJSON_URL\"}" | head -c 600; echo
elif [[ -n "$RECOMMEND_URL_REMOTE" ]]; then
  curl -s -X POST "$RECOMMEND_URL_REMOTE" -H "Content-Type: application/json" \
    -d "{\"lat\":42.6977,\"lng\":23.3219,\"radius\":5000,\"minScore\":0,\"file\":\"$CDN_GEOJSON_URL\"}" | head -c 600; echo
else
  echo "‚ö†Ô∏è Skip JSON recommend test (no reachable endpoint)."
fi

echo "üîé Smoke Test #3: /recommend multipart (best-effort)"
if curl -s -X POST -F "file=@$OUT_GEOJSON" "$RECOMMEND_URL_LOCAL" | head -c 200 >/dev/null 2>&1; then
  curl -s -X POST -F "file=@$OUT_GEOJSON" "$RECOMMEND_URL_LOCAL" | head -c 600; echo
elif [[ -n "$RECOMMEND_URL_REMOTE" ]]; then
  curl -s -X POST -F "file=@$OUT_GEOJSON" "$RECOMMEND_URL_REMOTE" | head -c 600; echo
else
  echo "‚ÑπÔ∏è Skip multipart test."
fi

echo "‚úÖ Done. CDN: $CDN_GEOJSON_URL"
